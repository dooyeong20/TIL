## 백준 #13459 구슬탈출

- 알고리즘 스터디 문제 풀이입니다.
- [백준 13459번](https://www.acmicpc.net/problem/13459) 에서 풀어볼 수 있습니다.

### 문제설명

구슬이 두개 있는 장난감이 있을 때, 이를 상하좌우로 움직여 빨간색 구슬을 구멍으로 빼내는 문제이다. 단, 이때 파란색 구슬은 어떠한 방법으로도 구멍에 빠지면 안된다. 이 때, 빨간색 구슬만을 10번 이내의 움직임으로 꺼낼 수 있는지 없는지 알아내는 것이 문제이다.

### 풀이

이 문제는 흔한 그래프 완전탐색 문제이다. 하지만 구슬들이 움직이는 조건들이 까다롭기 때문에 조건을 잘 나누어 dfs로 풀이해주었다.

먼저 구슬을 움직일때는

1. 빨간색 구슬과 파란색 구슬이 겹쳐서 움직이지 않는 경우
2. 만나는 경우

크게 이렇게 나누어 주었고, 만약 1~2 과정에서 파란색 구슬이 빠진다면 이 상황은 실패한 경우이기 때문에 따로 구분을 해주었다.

그리고 이러한 조건을 주고, dfs의 최대 깊이를 10으로 하여서 백트래킹으로 완전탐색해주었다. 이 때, 중요한 것은 board(2차원 배열)을 그때마다 deepcopy해서 주게되면 시간초과가 나오기 때문에, 아래와 같이 dfs호출시마다 board를 임의적으로 수정해서 다음 dfs로 넘겨주는 방식으로 접근하였다.

```python
.
.
.

board[red[0]][red[1]] = '.'
board[blue[0]][blue[1]] = '.'
board[hole[0]][hole[1]] = 'O'
board[rr][rc] = 'R'
board[br][bc] = 'B'
board[hole[0]][hole[1]] = 'O'

dfs(cnt+1, [rr, rc], [br, bc], d)

board[rr][rc] = '.'
board[br][bc] = '.'
board[hole[0]][hole[1]] = 'O'
board[red[0]][red[1]] = 'R'
board[blue[0]][blue[1]] = 'B'
board[hole[0]][hole[1]] = 'O'

.
.
.
```

### 소스코드

#### 1. Python

```python
from sys import stdin

N, M = map(int, stdin.readline().split())
board = [list(stdin.readline().strip()) for _ in range(N)]
dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
red, blue, hole = [0, 0], [0, 0], [0, 0]


def tilt(board, direct, oRed, oBlue):
    rr, rc = oRed
    br, bc = oBlue
    blueMet = redMet = goalIn = False
    result = True

    while board[rr + direct[0]][rc + direct[1]] != '#':
        rr += direct[0]
        rc += direct[1]

        if board[rr][rc] == 'B':
            blueMet = True
            break

        if board[rr][rc] == 'O':
            goalIn = True
            break

    while board[br + direct[0]][bc + direct[1]] != '#':
        br += direct[0]
        bc += direct[1]

        if board[br][bc] == 'R':
            redMet = True
            break

        if board[br][bc] == 'O':
            goalIn = True
            result = False
            break

    if goalIn:
        if redMet or blueMet:
            result = False
    else:
        if redMet:
            br, bc = rr - direct[0], rc - direct[1]

        elif blueMet:
            rr, rc = br - direct[0], bc - direct[1]

    return result, rr, rc, br, bc


goal = [False]


def dfs(cnt, red, blue, past):
    if goal[0] or cnt == 10:
        return

    for d in dirs:
        if d == past:
            continue
        res, rr, rc, br, bc = tilt(board, d, red, blue)

        if res:
            if board[rr][rc] == 'O':
                goal[0] = True
                return

            board[red[0]][red[1]] = '.'
            board[blue[0]][blue[1]] = '.'
            board[hole[0]][hole[1]] = 'O'
            board[rr][rc] = 'R'
            board[br][bc] = 'B'
            board[hole[0]][hole[1]] = 'O'

            dfs(cnt+1, [rr, rc], [br, bc], d)

            board[rr][rc] = '.'
            board[br][bc] = '.'
            board[hole[0]][hole[1]] = 'O'
            board[red[0]][red[1]] = 'R'
            board[blue[0]][blue[1]] = 'B'
            board[hole[0]][hole[1]] = 'O'


for i in range(1, N-1):
    for j in range(1, M-1):
        if board[i][j] == 'R':
            red = [i, j]

        if board[i][j] == "B":
            blue = [i, j]

        if board[i][j] == "O":
            hole = [i, j]

dfs(0, red, blue, 0)


if goal[0]:
    print(1)
else:
    print(0)

```

#### 2. JavaScript

```javascript
const fs = require("fs");
const input = fs.readFileSync("/dev/stdin").toString().split("\n");
const [N, M] = input
		.shift()
		.split(" ")
		.map((x) => +x),
	board = input.map((x) => x.split("")),
	red = [0, 0],
	blue = [0, 0],
	hole = [0, 0],
	dirs = [
		[-1, 0],
		[1, 0],
		[0, -1],
		[0, 1],
	];

const tilt = (board, di, red, blue) => {
	let res = true,
		blueMet = false,
		redMet = false,
		goalIn = false,
		[rr, rc] = [...red],
		[br, bc] = [...blue];

	while (board[rr + di[0]][rc + di[1]] != "#") {
		rr += di[0];
		rc += di[1];

		const cur = board[rr][rc];

		if (cur == "B") {
			blueMet = true;
			break;
		}

		if (cur == "O") {
			goalIn = true;
			break;
		}
	}

	while (board[br + di[0]][bc + di[1]] != "#") {
		br += di[0];
		bc += di[1];

		const cur = board[br][bc];

		if (cur == "R") {
			redMet = true;
			break;
		}

		if (cur == "O") {
			goalIn = true;
			res = false;
			break;
		}
	}

	if (goalIn) {
		if (redMet || blueMet) {
			res = false;
		}
	} else {
		if (redMet) {
			br = rr - di[0];
			bc = rc - di[1];
		} else if (blueMet) {
			rr = br - di[0];
			rc = bc - di[1];
		}
	}

	return [res, rr, rc, br, bc];
};

let goal = false;

const dfs = (board, cnt, red, blue, past) => {
	if (goal || cnt == 10) {
		return;
	}
	// console.log(board);
	const originalR = [...red],
		originalB = [...blue];

	for (let i = 0; i < 4; i++) {
		if (i == past) continue;

		const [res, rr, rc, br, bc] = tilt(board, dirs[i], [...red], [...blue]);

		if (!res) continue;

		if (board[rr][rc] == "O") {
			goal = true;
			return;
		}

		board[originalR[0]][originalR[1]] = ".";
		board[originalB[0]][originalB[1]] = ".";
		board[rr][rc] = "R";
		board[br][bc] = "B";
		dfs(board, cnt + 1, [rr, rc], [br, bc], i);
		board[rr][rc] = ".";
		board[br][bc] = ".";
		board[originalR[0]][originalR[1]] = "R";
		board[originalB[0]][originalB[1]] = "B";
		board[hole[0]][hole[1]] = "O";
	}
};

for (let i = 0; i < N; i++) {
	for (let j = 0; j < M; j++) {
		if (board[i][j] == "R") [red[0], red[1]] = [i, j];
		if (board[i][j] == "B") [blue[0], blue[1]] = [i, j];
		if (board[i][j] == "O") [hole[0], hole[1]] = [i, j];
	}
}

dfs(board, 0, red, blue, -1);
console.log(goal ? 1 : 0);
```
