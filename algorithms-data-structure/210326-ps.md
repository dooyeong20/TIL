# Problem Solving - 카드 정렬하기(G4)

### 1. 문제 [[ Link ]](https://www.acmicpc.net/problem/1715)

> 정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.
>
> 매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.
>
> N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

### 2. 입력

> 첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.

### 3. 예제 입/출력

> ```
> 3
> 10
> 20
> 40
> 
> 100
> ```

### 4. 풀이

그리디 문제로 접근하여, 카드의 비교 횟수가 가장 적으려면 카드들 중 가장 작은 단위의 카드들부터 차례대로 비교해나가는 방식으로 문제를 풀었다. 이 때, 가장 작은 수를 고르기 위해서 최소 힙을 사용했는데, 이는 카드를 비교해 나갈 때 마다 리스트를 정렬하거나, 최소 값을 찾는다면 시간 복잡도가 너무 커지기 때문이었다.  

따라서 최소 힙을 사용해 아래와 같이 문제를 풀어주었다.



#### Solution.py

```python
from sys import stdin
import heapq


def solution(n, cards):
    # n이 1일 경우에는 비교할 카드가 없기 때문에 1을 출력한다.
    if n == 1:
        return 0

    # cards 리스트를 (최소)힙으로 사용하기 위해 변환한다.
    heapq.heapify(cards)

    ans = 0
    tmp = []

    # 힙을 통해 시간복잡도를 줄여 카드의 덱이 작은 순으로 더해 그 값을 ans에 누적시켜 준다.
    # 이 때, cards 리스트에 카드가 하나만 남았을 경우가 종료 조건이 된다.
    while n > 1:
        tmp = heapq.heappop(cards) + heapq.heappop(cards)
        ans += tmp
        heapq.heappush(cards, tmp)
        n -= 1

    return ans


n = int(input())
cards = [int(stdin.readline()) for _ in range(n)]

print(solution(n, cards))

```



### 5. 분류

- 자료구조
- 그리디 알고리즘
- 우선순위 큐