# DP

두 가지 조건을 만족해야만 동적프로그래밍이라고 할 수 있다.

- Optimal Substructure: 부분 문제들의 최적해가 전체의 최적해를 이루어야 한다.
  - 잘게 쪼개진 부분 그때그때 최적의 선택을 해나간다(그리디 greedy)
  - Optimal Substructure가 아닌데 그리디로 풀면 최적해가 아니게 된다.
- Overlapping Sub-Problems: 동일한 부분 문제가 여러번 발생해야 한다.
  - 이 조건이 만족되지 않으면 분할정복(Divide & Conquer) 문제라고 한다.(merge sort, quick sort)
- 중복되는 연산을 미리 캐싱해 두고, 중복 연산이 발생할 때 마다 참조하여 연산을 줄인다. (Memoization)

## DP 종류

- Top-Down 접근법
  - 큰 문제부터 시작하여, 작은 문제로 나누는 접근법
  - 일반적으로 재귀적으로 구현(Recursion)할 때 사용된다.

```python
fibo = dict()
fibo[0] = 0
fibo[1] = 1

def fibonacci(n):
    if n in fibo:
        return fibo[n]

    res = fibonacci(n-1) + fibonacci(n-2)
    fibo[n] = res
    return res
```

- Bottom-Up 접근법
  - 문제를 미리 나누어 두고, 작은 문제의 답을 모아 큰 문제를 해결하는 접근법
  - 일반적으로 반복적으로 구현(Iteration)할 때 사용된다.

```python
def fibonacci(n):
    fibo = [None] * (n + 1)
    fibo[0], fibo[1] = 0, 1

    for i in range(2, n + 1):
        fibo[i] = fibo[i - 1] + fibo[i - 2]

    return fibo[n]
```

- DP를 너무 naive하게 사용하다보면 O(n)의 공간을 낭비하게 된다.

## DP 활용 - 0-1 배낭 문제(Knapsack)

- 배낭에 담을 수 있는 무게의 최대값이 정해져 있을 때, 배낭에 담은 짐의 가치가 최대가 되게 하는 문제
- 각 짐은 무게와 가치를 가지고 있으며, 0-1 배낭 문제에서는 짐을 쪼갤 수 없다.

- dp 반복적으로 다 구하는 것 tabulization

# Homework

두 개 다 풀기

- 직사각형문제
- 도둑질문제
