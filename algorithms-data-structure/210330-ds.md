# 이전 강의

## 이진 탐색 트리 삭제 매서드 중 ...

```python
# remove 에서 자식이 두명 있을 경우 핵심 코드

# node = 지울 노드
# parent = 지울 노드의 부모 노드

prev = node
curr = node.left

while curr.right:
    prev = curr
    curr = curr.right

if prev != node:            # 바로 왼쪽이 curr 가 아니고 좀 타고 내려가는 경우
    prev.right = curr.left
else:                       # 바로 왼쪽인 curr 일 경우
    prev.left = curr.left

curr.left = node.left
curr.right = node.right

if parent is None:
    self.root = curr
elif direction == 'left':
    parent.left = curr
else:
    parent.right = curr
```

# 그래프

그래프는 순서가 없다 !! 중요!!

## 그래프의 탐색

- 사이클이 있을 수 있기 때문에 트리와 달리 노드의 방문 여부 `visited` 를 검사해야 함
- bfs, dfs 가 사용될 수 있음
- bfs
  - `visited` 검사해야 함
  - bfs 를 통해서 곧바로 연결되어 있는 애들이 큐에 들어가기 때문에 가까운 노드부터 검색해나갈 수 있다. 즉, 출발 vertex로부터의 distance를 구해나갈 수 있다.
  - 최단 경로, 임의의 경로를 찾을 때 사용
  - Queue를 사용해 반복적인 방법으로 구현 가능
- dfs
  - 모든 vertex를 방문하고자 할 때 주로 사용함 (순회용)
  - `visited`를 검사해야함
  - 재귀를 이용해 전위 순회 형태로 구현 !

# 알고리즘

## 정렬 알고리즘이란

- 정렬 알고리즘은 비내림차순이다(오름차순이라고 안함. 중복되는 값이 있을 수 있기 때문)
  - 즉, 다음 원소보다 작지는 않다
- 정렬 알고리즘의 출력은 입력을 재배열하여 만든 순열이다.

  - 추가되거나, 삭제되지 않고 재배열된 것이 다임
  - 비교 연산, swap 연산 등

- 정렬 알고리즘을 앞단에 설명하는 이유
  - 점근 표기법
  - 분할 정복 알고리즘
  - 최악, 최선, 평균적인 경우 등등 설명하기 좋음

## 정렬 알고리즘의 종류

- In-place 알고리즘: 정렬을 수행하는 데에 추가 메모리가 O(logN) 이하로 사용되는 알고리즘
- Stable 알고리즘: 동일 값의 정렬 전후에 순서가 유지되는 알고리즘
  - 예를 들어서 [1, 5_0, 2, 5_1] 일때 [1, 2, 5_0, 5_1] 이 되면 Stable 하다.
  - Stable -> 두 가지 이상의 값(key)으로 정렬하는 경우에 처음 소팅된 결과를 보장할 수 있다.

### 버블 정렬

!! 가장 큰 수가 쭉쭉 밀려서 끝으로 감 !!

- 인접한 두 원소를 검사해 정렬
- 마지막 원소를 제외하고 동작 반복

- 최악의 경우: O(n^2)
  - 거꾸로 뒤집어져 있는 경우
- 최선의 경우: O(n)
  - 이미 정렬되어 있는 경우
- 평균적인 경우: O(n^2))
- 공간 복잡도는 O(1) - 추가 메모리를 필요로하지 않음

```python
def bubble_sort(x):
    length = len(x)-1
    for i in range(length):
        swapped = False
        for j in range(length-i):
            if x[j] > x[j+1]:
                swapped = True
                x[j], x[j+1] = x[j+1], x[j]
        if swapped is False:  # 한번 쭉 봤는데 swap이 없다? 그러면 모두 정렬되어 있는 상태임
            break
    return x
```

### 삽입 정렬

- 이미 정렬된 부분(앞) 정렬되지 않은 영역(뒤)로 나뉜다
- 정렬되지 않은 영역의 값을 정렬된 영역(앞)에 하나씩 삽입한다
- 첫 번재 요소는 이미 정렬되어 있다고 가정(길이가 1인 리스트는 이미 정렬되어 있기 때문)  
  그리고 2번째 요소부터 하나씩 뒤로 탐색하며 앞으로 진행해 알맞는 곳에 삽입

- 공간 복잡도: O(1)
- 시간 복잡도
  - 최악의 경우: O(n^2)
  - 최선의 경우: O(n)
  - 평균적인 경우: O(n^2)

```python
def insert_sort(x):
    for i in range(1, len(x)):
        j = i - 1
        key = x[i]
        while x[j] > key and j >= 0:    # 입력되는 값을 거꾸로 찾아나가며 한칸씩 밀면서 작동함
            x[j+1] = x[j]
            j = j - 1
        x[j+1] = key
    return x
```

### 참고 지식

- algorithm은 정확한 답이 나와야 함
- method는 근사한 답을 내면 됨
